#include <PalNetArchiveReader.h>

namespace Palworld {
	PalNetArchiveReader::PalNetArchiveReader(const FPalNetArchive& archive)
	{
		for (auto& byte : archive.Bytes)
		{
			m_byteArray.push_back(byte);
		}
	}

	PalNetArchiveReader::~PalNetArchiveReader()
	{

	}

	void PalNetArchiveReader::Read(std::wstring& outString)
	{
        if (m_byteArray.size() < 4)
        {
            throw std::runtime_error("Archive doesn't have enough bytes to parse message length!");
        }

        struct ConvertedMessage {
            int Length;
            std::wstring Message;
        };
        ConvertedMessage Msg{};

        std::memcpy(&Msg.Length, m_byteArray.data(), sizeof(int));

        if (Msg.Length <= 0)
        {
            throw std::runtime_error("Archive's message length was 0 or less!");
        }

        Msg.Length *= 2;

        m_byteArray.erase(m_byteArray.begin(), m_byteArray.begin() + sizeof(int));

        if (m_byteArray.size() <= 0)
        {
            throw std::runtime_error("Archive's size was 0 or less after parsing message length!");
        }

        if (m_byteArray.size() < Msg.Length)
        {
            throw std::runtime_error("Archive's size was less than message length!");
        }

        if (Msg.Length % sizeof(wchar_t) != 0) {
            throw std::runtime_error("Archive's message length is not a multiple of wchar_t!");
        }

        outString = std::wstring(reinterpret_cast<wchar_t*>(m_byteArray.data()), Msg.Length / sizeof(wchar_t));
	}
}